<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>Class: EventMachine::Connection</title>

	<link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

	<script src="../js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>

</head>
<body class="class">

	<div id="metadata">
		<div id="home-metadata">
			<div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
			</div>
		</div>

		<div id="file-metadata">
			<div id="file-list-section" class="section">
				<h3 class="section-header">In Files</h3>
				<div class="section-body">
					<ul>
					
						<li><a href="../lib/em/connection_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/em/connection.rb">lib/em/connection.rb</a></li>
					
						<li><a href="../lib/jeventmachine_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/jeventmachine.rb">lib/jeventmachine.rb</a></li>
					
						<li><a href="../lib/pr_eventmachine_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/pr_eventmachine.rb">lib/pr_eventmachine.rb</a></li>
					
					</ul>
				</div>
			</div>

			
		</div>

		<div id="class-metadata">

			<!-- Parent Class -->
			
			<div id="parent-class-section" class="section">
				<h3 class="section-header">Parent</h3>
				
				<p class="link">Object</p>
				
			</div>
			

			<!-- Namespace Contents -->
			

			<!-- Method Quickref -->
			
			<div id="method-list-section" class="section">
				<h3 class="section-header">Methods</h3>
				<ul class="link-list">
					
					<li><a href="#M000314">#associate_callback_target</a></li>
					
					<li><a href="#M000042">#close_connection</a></li>
					
					<li><a href="#M000045">#close_connection_after_writing</a></li>
					
					<li><a href="#M000056">#comm_inactivity_timeout</a></li>
					
					<li><a href="#M000057">#comm_inactivity_timeout=</a></li>
					
					<li><a href="#M000048">#connection_completed</a></li>
					
					<li><a href="#M000043">#detach</a></li>
					
					<li><a href="#M000047">#error?</a></li>
					
					<li><a href="#M000342">#get_outbound_data_size</a></li>
					
					<li><a href="#M000050">#get_peer_cert</a></li>
					
					<li><a href="#M000052">#get_peername</a></li>
					
					<li><a href="#M000054">#get_pid</a></li>
					
					<li><a href="#M000044">#get_sock_opt</a></li>
					
					<li><a href="#M000053">#get_sockname</a></li>
					
					<li><a href="#M000055">#get_status</a></li>
					
					<li><a href="#M000065">#notify_readable=</a></li>
					
					<li><a href="#M000066">#notify_readable?</a></li>
					
					<li><a href="#M000067">#notify_writable=</a></li>
					
					<li><a href="#M000068">#notify_writable?</a></li>
					
					<li><a href="#M000069">#pause</a></li>
					
					<li><a href="#M000071">#paused?</a></li>
					
					<li><a href="#M000059">#pending_connect_timeout</a></li>
					
					<li><a href="#M000060">#pending_connect_timeout=</a></li>
					
					<li><a href="#M000034">#post_init</a></li>
					
					<li><a href="#M000040">#proxy_incoming_to</a></li>
					
					<li><a href="#M000039">#proxy_target_unbound</a></li>
					
					<li><a href="#M000035">#receive_data</a></li>
					
					<li><a href="#M000062">#reconnect</a></li>
					
					<li><a href="#M000070">#resume</a></li>
					
					<li><a href="#M000046">#send_data</a></li>
					
					<li><a href="#M000051">#send_datagram</a></li>
					
					<li><a href="#M000063">#send_file_data</a></li>
					
					<li><a href="#M000058">#set_comm_inactivity_timeout</a></li>
					
					<li><a href="#M000061">#set_pending_connect_timeout</a></li>
					
					<li><a href="#M000036">#ssl_handshake_completed</a></li>
					
					<li><a href="#M000037">#ssl_verify_peer</a></li>
					
					<li><a href="#M000049">#start_tls</a></li>
					
					<li><a href="#M000041">#stop_proxying</a></li>
					
					<li><a href="#M000064">#stream_file_data</a></li>
					
					<li><a href="#M000038">#unbind</a></li>
					
				</ul>
			</div>
			

			<!-- Included Modules -->
			
		</div>

		<div id="project-metadata">
			
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="../images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="../EventMachine.html">EventMachine</a></li>
				
					<li><a href="../EventMachine.html">EventMachine</a></li>
				
					<li><a href="../EventMachine/Channel.html">EventMachine::Channel</a></li>
				
					<li><a href="../EventMachine/Connection.html">EventMachine::Connection</a></li>
				
					<li><a href="../EventMachine/ConnectionNotBound.html">EventMachine::ConnectionNotBound</a></li>
				
					<li><a href="../EventMachine/DatagramObject.html">EventMachine::DatagramObject</a></li>
				
					<li><a href="../EventMachine/DefaultDeferrable.html">EventMachine::DefaultDeferrable</a></li>
				
					<li><a href="../EventMachine/Deferrable.html">EventMachine::Deferrable</a></li>
				
					<li><a href="../EventMachine/DeferrableChildProcess.html">EventMachine::DeferrableChildProcess</a></li>
				
					<li><a href="../EventMachine/Error.html">EventMachine::Error</a></li>
				
					<li><a href="../EventMachine/EvmaKeyboard.html">EventMachine::EvmaKeyboard</a></li>
				
					<li><a href="../EventMachine/EvmaTCPClient.html">EventMachine::EvmaTCPClient</a></li>
				
					<li><a href="../EventMachine/EvmaTCPServer.html">EventMachine::EvmaTCPServer</a></li>
				
					<li><a href="../EventMachine/EvmaUDPSocket.html">EventMachine::EvmaUDPSocket</a></li>
				
					<li><a href="../EventMachine/EvmaUNIXClient.html">EventMachine::EvmaUNIXClient</a></li>
				
					<li><a href="../EventMachine/EvmaUNIXServer.html">EventMachine::EvmaUNIXServer</a></li>
				
					<li><a href="../EventMachine/FileStreamer.html">EventMachine::FileStreamer</a></li>
				
					<li><a href="../EventMachine/FileWatch.html">EventMachine::FileWatch</a></li>
				
					<li><a href="../EventMachine/JEM.html">EventMachine::JEM</a></li>
				
					<li><a href="../EventMachine/LoopbreakReader.html">EventMachine::LoopbreakReader</a></li>
				
					<li><a href="../EventMachine/PeriodicTimer.html">EventMachine::PeriodicTimer</a></li>
				
					<li><a href="../EventMachine/ProcessWatch.html">EventMachine::ProcessWatch</a></li>
				
					<li><a href="../EventMachine/Protocols.html">EventMachine::Protocols</a></li>
				
					<li><a href="../EventMachine/Protocols.html">EventMachine::Protocols</a></li>
				
					<li><a href="../EventMachine/Protocols/HeaderAndContentProtocol.html">EventMachine::Protocols::HeaderAndContentProtocol</a></li>
				
					<li><a href="../EventMachine/Protocols/HttpClient.html">EventMachine::Protocols::HttpClient</a></li>
				
					<li><a href="../EventMachine/Protocols/HttpClient2.html">EventMachine::Protocols::HttpClient2</a></li>
				
					<li><a href="../EventMachine/Protocols/LineAndTextProtocol.html">EventMachine::Protocols::LineAndTextProtocol</a></li>
				
					<li><a href="../EventMachine/Protocols/LineText2.html">EventMachine::Protocols::LineText2</a></li>
				
					<li><a href="../EventMachine/Protocols/Memcache.html">EventMachine::Protocols::Memcache</a></li>
				
					<li><a href="../EventMachine/Protocols/ObjectProtocol.html">EventMachine::Protocols::ObjectProtocol</a></li>
				
					<li><a href="../EventMachine/Protocols/Postgres3.html">EventMachine::Protocols::Postgres3</a></li>
				
					<li><a href="../EventMachine/Protocols/SASLauth.html">EventMachine::Protocols::SASLauth</a></li>
				
					<li><a href="../EventMachine/Protocols/SASLauthclient.html">EventMachine::Protocols::SASLauthclient</a></li>
				
					<li><a href="../EventMachine/Protocols/SmtpClient.html">EventMachine::Protocols::SmtpClient</a></li>
				
					<li><a href="../EventMachine/Protocols/SmtpServer.html">EventMachine::Protocols::SmtpServer</a></li>
				
					<li><a href="../EventMachine/Protocols/Socks4.html">EventMachine::Protocols::Socks4</a></li>
				
					<li><a href="../EventMachine/Protocols/Stomp.html">EventMachine::Protocols::Stomp</a></li>
				
					<li><a href="../EventMachine/Protocols/Stomp/Message.html">EventMachine::Protocols::Stomp::Message</a></li>
				
					<li><a href="../EventMachine/Queue.html">EventMachine::Queue</a></li>
				
					<li><a href="../EventMachine/Reactor.html">EventMachine::Reactor</a></li>
				
					<li><a href="../EventMachine/Selectable.html">EventMachine::Selectable</a></li>
				
					<li><a href="../EventMachine/SpawnedProcess.html">EventMachine::SpawnedProcess</a></li>
				
					<li><a href="../EventMachine/StreamObject.html">EventMachine::StreamObject</a></li>
				
					<li><a href="../EventMachine/Timer.html">EventMachine::Timer</a></li>
				
					<li><a href="../EventMachine/UnknownTimerFired.html">EventMachine::UnknownTimerFired</a></li>
				
					<li><a href="../EventMachine/Unsupported.html">EventMachine::Unsupported</a></li>
				
					<li><a href="../EventMachine/UuidGenerator.html">EventMachine::UuidGenerator</a></li>
				
					<li><a href="../Evma.html">Evma</a></li>
				
					<li><a href="../Evma/Container.html">Evma::Container</a></li>
				
					<li><a href="../Evma/ContainerHasObject.html">Evma::ContainerHasObject</a></li>
				
					<li><a href="../Evma/DatagramProtocol.html">Evma::DatagramProtocol</a></li>
				
					<li><a href="../Evma/Protocol.html">Evma::Protocol</a></li>
				
					<li><a href="../Evma/ProtocolFactory.html">Evma::ProtocolFactory</a></li>
				
					<li><a href="../Evma/Reactor.html">Evma::Reactor</a></li>
				
					<li><a href="../Evma/StreamProtocol.html">Evma::StreamProtocol</a></li>
				
					<li><a href="../Evma/TcpServerFactory.html">Evma::TcpServerFactory</a></li>
				
					<li><a href="../Evma/TcpSocket.html">Evma::TcpSocket</a></li>
				
					<li><a href="../Evma/UnknownTarget.html">Evma::UnknownTarget</a></li>
				
					<li><a href="../Evma/UnsupportedCallback.html">Evma::UnsupportedCallback</a></li>
				
					<li><a href="../BufferedTokenizer.html">BufferedTokenizer</a></li>
				
					<li><a href="../IO.html">IO</a></li>
				
					<li><a href="../JavaFields.html">JavaFields</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h1 class="class">EventMachine::Connection</h1>

		<div id="description">
			<p>
<a href="Connection.html">EventMachine::Connection</a> is a class that is
instantiated by EventMachine&#8217;s processing loop whenever a new
connection is created. (New connections can be either initiated locally to
a remote server or accepted locally from a remote client.) When a <a
href="Connection.html">Connection</a> object is instantiated, it <em>mixes
in</em> the functionality contained in the user-defined module specified in
calls to <a href="../EventMachine.html#M000241">EventMachine#connect</a> or
<a href="../EventMachine.html#M000238">EventMachine#start_server</a>.
User-defined handler modules may redefine any or all of the standard
methods defined here, as well as add arbitrary additional code that will
also be mixed in.
</p>
<p>
<a href="../EventMachine.html">EventMachine</a> manages one object
inherited from <a href="Connection.html">EventMachine::Connection</a> (and
containing the mixed-in user code) for every network connection that is
active at any given time. The event loop will automatically call methods on
<a href="Connection.html">EventMachine::Connection</a> objects whenever
specific events occur on the corresponding connections, as described below.
</p>
<p>
This class is never instantiated by user code, and does not publish an
initialize method. The instance methods of <a
href="Connection.html">EventMachine::Connection</a> which may be called by
the event loop are: <a href="Connection.html#M000034">post_init</a>, <a
href="Connection.html#M000035">receive_data</a>, and unbind. All of the
other instance methods defined here are called only by user code.
</p>

		</div>

		<!-- Constants -->
		

		<!-- Attributes -->
		

		<!-- Methods -->
		
		<div id="public-instance-method-details" class="method-section section">
			<h3 class="section-header">Public Instance Methods</h3>

		
			<div id="associate-callback-target-method" class="method-detail ">
				<a name="M000314"></a>

				<div class="method-heading">
				
					<span class="method-name">associate_callback_target</span><span
						class="method-args">(sig)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="associate-callback-target-source">
<pre>
     <span class="ruby-comment cmt"># File lib/jeventmachine.rb, line 252</span>
252:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">associate_callback_target</span> <span class="ruby-identifier">sig</span>
253:       <span class="ruby-comment cmt"># No-op for the time being</span>
254:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="close-connection-method" class="method-detail ">
				<a name="M000042"></a>

				<div class="method-heading">
				
					<span class="method-name">close_connection</span><span
						class="method-args">(after_writing = false)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a
href="Connection.html#M000042">EventMachine::Connection#close_connection</a>
is called only by user code, and never by the event loop. You may call this
method against a connection object in any callback handler, whether or not
the callback was made against the connection you want to close. <a
href="Connection.html#M000042">close_connection</a> <em>schedules</em> the
connection to be closed at the next available opportunity within the event
loop. You may not assume that the connection is closed when <a
href="Connection.html#M000042">close_connection</a> returns. In particular,
the framework will callback the unbind method for the particular connection
at a point shortly after you call close_connection. You may assume that the
unbind callback will take place sometime after your call to <a
href="Connection.html#M000042">close_connection</a> completes. In other
words, the unbind callback will not re-enter your code &#8220;inside&#8221;
of your call to close_connection. However, it&#8217;s not guaranteed that a
future version of <a href="../EventMachine.html">EventMachine</a> will not
change this behavior.
</p>
<p>
<a href="Connection.html#M000042">close_connection</a> will <em>silently
discard</em> any outbound data which you have sent to the connection using
<a href="Connection.html#M000046">EventMachine::Connection#send_data</a>
but which has not yet been sent across the network. If you want to avoid
this behavior, use <a
href="Connection.html#M000045">EventMachine::Connection#close_connection_after_writing</a>.
</p>
					

					
					<div class="method-source-code"
						id="close-connection-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 168</span>
168:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">close_connection</span> <span class="ruby-identifier">after_writing</span> = <span class="ruby-keyword kw">false</span>
169:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">close_connection</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">after_writing</span>
170:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="close-connection-after-writing-method" class="method-detail ">
				<a name="M000045"></a>

				<div class="method-heading">
				
					<span class="method-name">close_connection_after_writing</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a
href="Connection.html#M000045">EventMachine::Connection#close_connection_after_writing</a>
is a variant of close_connection. All of the descriptive comments given for
<a href="Connection.html#M000042">close_connection</a> also apply to <a
href="Connection.html#M000045">close_connection_after_writing</a>, <em>with
one exception:</em> If the connection has outbound data sent using send_dat
but which has not yet been sent across the network, <a
href="Connection.html#M000045">close_connection_after_writing</a> will
schedule the connection to be closed <em>after</em> all of the outbound
data has been safely written to the remote peer.
</p>
<p>
Depending on the amount of outgoing data and the speed of the network,
considerable time may elapse between your call to <a
href="Connection.html#M000045">close_connection_after_writing</a> and the
actual closing of the socket (at which time the unbind callback will be
called by the event loop). During this time, you <em>may not</em> call <a
href="Connection.html#M000046">send_data</a> to transmit additional data
(that is, the connection is closed for further writes). In very rare cases,
you may experience a <a href="Connection.html#M000035">receive_data</a>
callback after your call to <a
href="Connection.html#M000045">close_connection_after_writing</a>,
depending on whether incoming data was in the process of being received on
the connection at the moment when you called
close_connection_after_writing. Your protocol handler must be prepared to
properly deal with such data (probably by ignoring it).
</p>
					

					
					<div class="method-source-code"
						id="close-connection-after-writing-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 199</span>
199:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">close_connection_after_writing</span>
200:       <span class="ruby-identifier">close_connection</span> <span class="ruby-keyword kw">true</span>
201:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="comm-inactivity-timeout-method" class="method-detail ">
				<a name="M000056"></a>

				<div class="method-heading">
				
					<span class="method-name">comm_inactivity_timeout</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000056">comm_inactivity_timeout</a> returns the
current value (float in seconds) of the inactivity-timeout property of
network-connection and datagram-socket objects. A nonzero value indicates
that the connection or socket will automatically be closed if no read or
write activity takes place for at least that number of seconds. A zero
value (the default) specifies that no automatic timeout will take place.
</p>
					

					
					<div class="method-source-code"
						id="comm-inactivity-timeout-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 454</span>
454:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">comm_inactivity_timeout</span>
455:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_comm_inactivity_timeout</span> <span class="ruby-ivar">@signature</span>
456:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="comm-inactivity-timeout--method" class="method-detail ">
				<a name="M000057"></a>

				<div class="method-heading">
				
					<span class="method-name">comm_inactivity_timeout=</span><span
						class="method-args">(value)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Alias for <a
href="Connection.html#M000058">set_comm_inactivity_timeout</a>.
</p>
					

					
					<div class="method-source-code"
						id="comm-inactivity-timeout--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 459</span>
459:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">comm_inactivity_timeout=</span> <span class="ruby-identifier">value</span>
460:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">set_comm_inactivity_timeout</span> <span class="ruby-identifier">value</span>
461:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="connection-completed-method" class="method-detail ">
				<a name="M000048"></a>

				<div class="method-heading">
				
					<span class="method-name">connection_completed</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000048">connection_completed</a> is called by the
event loop when a remote TCP connection attempt completes successfully. You
can expect to get this notification after calls to <a
href="../EventMachine.html#M000241">EventMachine#connect</a>. Remember that
<a href="../EventMachine.html">EventMachine</a> makes remote connections
asynchronously, just as with any other kind of network event. <a
href="Connection.html#M000048">connection_completed</a> is intended
primarily to assist with network diagnostics. For normal protocol handling,
use <a href="Connection.html#M000034">post_init</a> to perform initial work
on a new connection (such as send an initial set of data). <a
href="Connection.html#M000034">post_init</a> will always be called. <a
href="Connection.html#M000048">connection_completed</a> will only be called
in case of a successful completion. A connection-attempt which fails will
receive a call to <a href="Connection.html#M000038">unbind</a> after the
failure.
</p>
					

					
					<div class="method-source-code"
						id="connection-completed-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 246</span>
246:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">connection_completed</span>
247:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="detach-method" class="method-detail ">
				<a name="M000043"></a>

				<div class="method-heading">
				
					<span class="method-name">detach</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000043">EventMachine::Connection#detach</a> will
remove the given connection from the event loop. The connection&#8217;s
socket remains open and its file descriptor number is returned
</p>
					

					
					<div class="method-source-code"
						id="detach-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 174</span>
174:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">detach</span>
175:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">detach_fd</span> <span class="ruby-ivar">@signature</span>
176:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="error--method" class="method-detail ">
				<a name="M000047"></a>

				<div class="method-heading">
				
					<span class="method-name">error?</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Returns true if the connection is in an error state, false otherwise. In
general, you can detect the occurrence of communication errors or
unexpected disconnection by the remote peer by handing the <a
href="Connection.html#M000038">unbind</a> method. In some cases, however,
it&#8217;s useful to check the status of the connection using <a
href="Connection.html#M000047">error?</a> before attempting to send data.
This function is synchronous: it will return immediately without blocking.
</p>
					

					
					<div class="method-source-code"
						id="error--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 232</span>
232:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">error?</span>
233:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">report_connection_error_status</span>(<span class="ruby-ivar">@signature</span>) <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
234:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="get-outbound-data-size-method" class="method-detail ">
				<a name="M000342"></a>

				<div class="method-heading">
				
					<span class="method-name">get_outbound_data_size</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="get-outbound-data-size-source">
<pre>
     <span class="ruby-comment cmt"># File lib/pr_eventmachine.rb, line 224</span>
224:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_outbound_data_size</span>
225:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_outbound_data_size</span> <span class="ruby-ivar">@signature</span>
226:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="get-peer-cert-method" class="method-detail ">
				<a name="M000050"></a>

				<div class="method-heading">
				
					<span class="method-name">get_peer_cert</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
If SSL/TLS is active on the connection, <a
href="Connection.html#M000050">get_peer_cert</a> returns the remote X509
certificate as a String, in the popular PEM format. This can then be used
for arbitrary validation of a peer&#8217;s certificate in your code.
</p>
<p>
This should be called in/after the <a
href="Connection.html#M000036">ssl_handshake_completed</a> callback, which
indicates that SSL/TLS is active. Using this callback is important, because
the certificate may not be available until the time it is executed. Using
<a href="Connection.html#M000034">post_init</a> or <a
href="Connection.html#M000048">connection_completed</a> is not adequate,
because the SSL handshake may still be taking place.
</p>
<p>
<a href="Connection.html#M000050">get_peer_cert</a> will return <b>nil</b>
if:
</p>
<ul>
<li><p>
<a href="../EventMachine.html">EventMachine</a> is not built with OpenSSL
support
</p>
</li>
<li><p>
SSL/TLS is not active on the connection
</p>
</li>
<li><p>
SSL/TLS handshake is not yet complete
</p>
</li>
<li><p>
Remote peer for any other reason has not presented a certificate
</p>
</li>
</ul>
<h3>Example:</h3>
<pre>
 module Handler

  def post_init
    puts &quot;Starting TLS&quot;
    start_tls
  end

  def ssl_handshake_completed
    puts get_peer_cert
    close_connection
  end

  def unbind
    EventMachine::stop_event_loop
  end

 end

 EM.run {
  EventMachine::connect &quot;mail.google.com&quot;, 443, Handler
 }
</pre>
<p>
Output:
</p>
<pre>
 -----BEGIN CERTIFICATE-----
 MIIDIjCCAougAwIBAgIQbldpChBPqv+BdPg4iwgN8TANBgkqhkiG9w0BAQUFADBM
 MQswCQYDVQQGEwJaQTElMCMGA1UEChMcVGhhd3RlIENvbnN1bHRpbmcgKFB0eSkg
 THRkLjEWMBQGA1UEAxMNVGhhd3RlIFNHQyBDQTAeFw0wODA1MDIxNjMyNTRaFw0w
 OTA1MDIxNjMyNTRaMGkxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlh
 MRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRMwEQYDVQQKEwpHb29nbGUgSW5jMRgw
 FgYDVQQDEw9tYWlsLmdvb2dsZS5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ
 AoGBALlkxdh2QXegdElukCSOV2+8PKiONIS+8Tu9K7MQsYpqtLNC860zwOPQ2NLI
 3Zp4jwuXVTrtzGuiqf5Jioh35Ig3CqDXtLyZoypjZUQcq4mlLzHlhIQ4EhSjDmA7
 Ffw9y3ckSOQgdBQWNLbquHh9AbEUjmhkrYxIqKXeCnRKhv6nAgMBAAGjgecwgeQw
 KAYDVR0lBCEwHwYIKwYBBQUHAwEGCCsGAQUFBwMCBglghkgBhvhCBAEwNgYDVR0f
 BC8wLTAroCmgJ4YlaHR0cDovL2NybC50aGF3dGUuY29tL1RoYXd0ZVNHQ0NBLmNy
 bDByBggrBgEFBQcBAQRmMGQwIgYIKwYBBQUHMAGGFmh0dHA6Ly9vY3NwLnRoYXd0
 ZS5jb20wPgYIKwYBBQUHMAKGMmh0dHA6Ly93d3cudGhhd3RlLmNvbS9yZXBvc2l0
 b3J5L1RoYXd0ZV9TR0NfQ0EuY3J0MAwGA1UdEwEB/wQCMAAwDQYJKoZIhvcNAQEF
 BQADgYEAsRwpLg1dgCR1gYDK185MFGukXMeQFUvhGqF8eT/CjpdvezyKVuz84gSu
 6ccMXgcPQZGQN/F4Xug+Q01eccJjRSVfdvR5qwpqCj+6BFl5oiKDBsveSkrmL5dz
 s2bn7TdTSYKcLeBkjXxDLHGBqLJ6TNCJ3c4/cbbG5JhGvoema94=
 -----END CERTIFICATE-----
</pre>
<p>
You can do whatever you want with the certificate String, such as load it
as a certificate object using the OpenSSL library, and check it&#8217;s
fields.
</p>
					

					
					<div class="method-source-code"
						id="get-peer-cert-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 375</span>
375:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_peer_cert</span>
376:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_peer_cert</span> <span class="ruby-ivar">@signature</span>
377:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="get-peername-method" class="method-detail ">
				<a name="M000052"></a>

				<div class="method-heading">
				
					<span class="method-name">get_peername</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000052">get_peername</a> is used with
stream-connections to obtain the identity of the remotely-connected peer.
If a peername is available, this method returns a sockaddr structure. The
method returns nil if no peername is available. You can use
Socket.unpack_sockaddr_in and its variants to obtain the values contained
in the peername structure returned from <a
href="Connection.html#M000052">get_peername</a>.
</p>
<pre>
 require 'socket'
 module Handler
   def receive_data data
     port, ip = Socket.unpack_sockaddr_in(get_peername)
     puts &quot;got #{data.inspect} from #{ip}:#{port}&quot;
   end
 end</pre>
					

					
					<div class="method-source-code"
						id="get-peername-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 420</span>
420:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_peername</span>
421:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_peername</span> <span class="ruby-ivar">@signature</span>
422:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="get-pid-method" class="method-detail ">
				<a name="M000054"></a>

				<div class="method-heading">
				
					<span class="method-name">get_pid</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Returns the PID (kernel process identifier) of a subprocess associated with
this <a href="Connection.html">Connection</a> object. For use with <a
href="../EventMachine.html#M000259">EventMachine#popen</a> and similar
methods. Returns nil when there is no meaningful subprocess.
</p>
					

					
					<div class="method-source-code"
						id="get-pid-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 438</span>
438:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_pid</span>
439:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_subprocess_pid</span> <span class="ruby-ivar">@signature</span>
440:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="get-sock-opt-method" class="method-detail ">
				<a name="M000044"></a>

				<div class="method-heading">
				
					<span class="method-name">get_sock_opt</span><span
						class="method-args">(level, option)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="get-sock-opt-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 178</span>
178:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_sock_opt</span> <span class="ruby-identifier">level</span>, <span class="ruby-identifier">option</span>
179:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_sock_opt</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">option</span>
180:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="get-sockname-method" class="method-detail ">
				<a name="M000053"></a>

				<div class="method-heading">
				
					<span class="method-name">get_sockname</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000053">get_sockname</a> is used with
stream-connections to obtain the identity of the local side of the
connection. If a local name is available, this method returns a sockaddr
structure. The method returns nil if no local name is available. You can
use Socket#unpack_sockaddr_in and its variants to obtain the values
contained in the local-name structure returned from <a
href="Connection.html#M000053">get_sockname</a>.
</p>
					

					
					<div class="method-source-code"
						id="get-sockname-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 429</span>
429:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_sockname</span>
430:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_sockname</span> <span class="ruby-ivar">@signature</span>
431:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="get-status-method" class="method-detail ">
				<a name="M000055"></a>

				<div class="method-heading">
				
					<span class="method-name">get_status</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Returns a subprocess exit status. Only useful for popen. Call it in your <a
href="Connection.html#M000038">unbind</a> handler.
</p>
					

					
					<div class="method-source-code"
						id="get-status-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 445</span>
445:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_status</span>
446:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_subprocess_status</span> <span class="ruby-ivar">@signature</span>
447:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="notify-readable--method" class="method-detail ">
				<a name="M000065"></a>

				<div class="method-heading">
				
					<span class="method-name">notify_readable=</span><span
						class="method-args">(mode)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Enable notify_readable callbacks on this connection. Only possible if the
connection was created using <a
href="../EventMachine.html#M000244">EM.attach</a> and had
notify_readable/notify_writable defined on the handler.
</p>
					

					
					<div class="method-source-code"
						id="notify-readable--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 529</span>
529:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">notify_readable=</span> <span class="ruby-identifier">mode</span>
530:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">set_notify_readable</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">mode</span>
531:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="notify-readable--method" class="method-detail ">
				<a name="M000066"></a>

				<div class="method-heading">
				
					<span class="method-name">notify_readable?</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Returns true if the connection is being watched for readability.
</p>
					

					
					<div class="method-source-code"
						id="notify-readable--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 534</span>
534:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">notify_readable?</span>
535:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">is_notify_readable</span> <span class="ruby-ivar">@signature</span>
536:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="notify-writable--method" class="method-detail ">
				<a name="M000067"></a>

				<div class="method-heading">
				
					<span class="method-name">notify_writable=</span><span
						class="method-args">(mode)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Enable notify_writable callbacks on this connection. Only possible if the
connection was created using <a
href="../EventMachine.html#M000244">EM.attach</a> and had
notify_readable/notify_writable defined on the handler.
</p>
					

					
					<div class="method-source-code"
						id="notify-writable--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 540</span>
540:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">notify_writable=</span> <span class="ruby-identifier">mode</span>
541:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">set_notify_writable</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">mode</span>
542:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="notify-writable--method" class="method-detail ">
				<a name="M000068"></a>

				<div class="method-heading">
				
					<span class="method-name">notify_writable?</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Returns true if the connection is being watched for writability.
</p>
					

					
					<div class="method-source-code"
						id="notify-writable--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 545</span>
545:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">notify_writable?</span>
546:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">is_notify_writable</span> <span class="ruby-ivar">@signature</span>
547:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="pause-method" class="method-detail ">
				<a name="M000069"></a>

				<div class="method-heading">
				
					<span class="method-name">pause</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Pause a connection so that <a href="Connection.html#M000046">send_data</a>
and <a href="Connection.html#M000035">receive_data</a> events are not fired
until <a href="Connection.html#M000070">resume</a> is called.
</p>
					

					
					<div class="method-source-code"
						id="pause-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 550</span>
550:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pause</span>
551:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">pause_connection</span> <span class="ruby-ivar">@signature</span>
552:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="paused--method" class="method-detail ">
				<a name="M000071"></a>

				<div class="method-heading">
				
					<span class="method-name">paused?</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
True if the connect was paused using <a
href="Connection.html#M000069">pause</a>.
</p>
					

					
					<div class="method-source-code"
						id="paused--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 560</span>
560:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">paused?</span>
561:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">connection_paused?</span> <span class="ruby-ivar">@signature</span>
562:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="pending-connect-timeout-method" class="method-detail ">
				<a name="M000059"></a>

				<div class="method-heading">
				
					<span class="method-name">pending_connect_timeout</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000059">pending_connect_timeout</a> is the
duration after which a TCP connection in the connecting  state will fail.
It is important to distinguish this value from <a
href="Connection.html#M000056">comm_inactivity_timeout</a>, which looks at
how long since data was passed on an already established connection. The
value is a float in seconds.
</p>
					

					
					<div class="method-source-code"
						id="pending-connect-timeout-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 477</span>
477:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pending_connect_timeout</span>
478:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_pending_connect_timeout</span> <span class="ruby-ivar">@signature</span>
479:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="pending-connect-timeout--method" class="method-detail ">
				<a name="M000060"></a>

				<div class="method-heading">
				
					<span class="method-name">pending_connect_timeout=</span><span
						class="method-args">(value)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Alias for <a
href="Connection.html#M000061">set_pending_connect_timeout</a>.
</p>
					

					
					<div class="method-source-code"
						id="pending-connect-timeout--source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 482</span>
482:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pending_connect_timeout=</span> <span class="ruby-identifier">value</span>
483:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">set_pending_connect_timeout</span> <span class="ruby-identifier">value</span>
484:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="post-init-method" class="method-detail ">
				<a name="M000034"></a>

				<div class="method-heading">
				
					<span class="method-name">post_init</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000034">EventMachine::Connection#post_init</a> is
called by the event loop immediately after the network connection has been
established, and before resumption of the network loop. This method is
generally not called by user code, but is called automatically by the event
loop. The base-class implementation is a no-op. This is a very good place
to initialize instance variables that will be used throughout the lifetime
of the network connection.
</p>
					

					
					<div class="method-source-code"
						id="post-init-source">
<pre>
    <span class="ruby-comment cmt"># File lib/em/connection.rb, line 68</span>
68:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">post_init</span>
69:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="proxy-incoming-to-method" class="method-detail ">
				<a name="M000040"></a>

				<div class="method-heading">
				
					<span class="method-name">proxy_incoming_to</span><span
						class="method-args">(conn,bufsize=0)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a
href="Connection.html#M000040">EventMachine::Connection#proxy_incoming_to</a>
is called only by user code. It sets up a low-level proxy relay for all
data inbound for this connection, to the connection given as the argument.
This is essentially just a helper method for enable_proxy. See
EventMachine::enable_proxy documentation for details.
</p>
					

					
					<div class="method-source-code"
						id="proxy-incoming-to-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 141</span>
141:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">proxy_incoming_to</span>(<span class="ruby-identifier">conn</span>,<span class="ruby-identifier">bufsize</span>=<span class="ruby-value">0</span>)
142:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">enable_proxy</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">conn</span>, <span class="ruby-identifier">bufsize</span>)
143:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="proxy-target-unbound-method" class="method-detail ">
				<a name="M000039"></a>

				<div class="method-heading">
				
					<span class="method-name">proxy_target_unbound</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a
href="Connection.html#M000039">EventMachine::Connection#proxy_target_unbound</a>
is called by the reactor after attempting to relay incoming data to a
descriptor (set as a proxy target descriptor with
EventMachine::enable_proxy) that has already been closed.
</p>
					

					
					<div class="method-source-code"
						id="proxy-target-unbound-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 134</span>
134:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">proxy_target_unbound</span>
135:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="receive-data-method" class="method-detail ">
				<a name="M000035"></a>

				<div class="method-heading">
				
					<span class="method-name">receive_data</span><span
						class="method-args">(data)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000035">EventMachine::Connection#receive_data</a>
is called by the event loop whenever data has been received by the network
connection. It is never called by user code. <a
href="Connection.html#M000035">receive_data</a> is called with a single
parameter, a String containing the network protocol data, which may of
course be binary. You will generally redefine this method to perform your
own processing of the incoming data.
</p>
<p>
Here&#8217;s a key point which is essential to understanding the
event-driven programming model: <em><a
href="../EventMachine.html">EventMachine</a> knows absolutely nothing about
the protocol which your code implements.</em> You must not make any
assumptions about the size of the incoming data packets, or about their
alignment on any particular intra-message or PDU boundaries (such as line
breaks). <a href="Connection.html#M000035">receive_data</a> can and will
send you arbitrary chunks of data, with the only guarantee being that the
data is presented to your code in the order it was collected from the
network. Don&#8217;t even assume that the chunks of data will correspond to
network packets, as <a href="../EventMachine.html">EventMachine</a> can and
will coalesce several incoming packets into one, to improve performance.
The implication for your code is that you generally will need to implement
some kind of a state machine in your redefined implementation of
receive_data. For a better understanding of this, read through the examples
of specific protocol handlers in <a
href="Protocols.html">EventMachine::Protocols</a>
</p>
<p>
The base-class implementation of <a
href="Connection.html#M000035">receive_data</a> (which will be invoked if
you don&#8217;t redefine it) simply prints the size of each incoming data
packet to stdout.
</p>
					

					
					<div class="method-source-code"
						id="receive-data-source">
<pre>
    <span class="ruby-comment cmt"># File lib/em/connection.rb, line 96</span>
96:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">receive_data</span> <span class="ruby-identifier">data</span>
97:       <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;............&gt;&gt;&gt;#{data.length}&quot;</span>
98:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="reconnect-method" class="method-detail ">
				<a name="M000062"></a>

				<div class="method-heading">
				
					<span class="method-name">reconnect</span><span
						class="method-args">(server, port)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Reconnect to a given host/port with the current <a
href="Connection.html">EventMachine::Connection</a> instance
</p>
					

					
					<div class="method-source-code"
						id="reconnect-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 493</span>
493:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">reconnect</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>
494:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">reconnect</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>, <span class="ruby-keyword kw">self</span>
495:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="resume-method" class="method-detail ">
				<a name="M000070"></a>

				<div class="method-heading">
				
					<span class="method-name">resume</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Resume a connection&#8217;s <a href="Connection.html#M000046">send_data</a>
and <a href="Connection.html#M000035">receive_data</a> events.
</p>
					

					
					<div class="method-source-code"
						id="resume-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 555</span>
555:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">resume</span>
556:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">resume_connection</span> <span class="ruby-ivar">@signature</span>
557:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="send-data-method" class="method-detail ">
				<a name="M000046"></a>

				<div class="method-heading">
				
					<span class="method-name">send_data</span><span
						class="method-args">(data)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000046">EventMachine::Connection#send_data</a> is
only called by user code, never by the event loop. You call this method to
send data to the remote end of the network connection. <a
href="Connection.html#M000046">send_data</a> is called with a single String
argument, which may of course contain binary data. You can call <a
href="Connection.html#M000046">send_data</a> any number of times. <a
href="Connection.html#M000046">send_data</a> is an instance method of an
object derived from <a href="Connection.html">EventMachine::Connection</a>
and containing your mixed-in handler code), so if you call it without
qualification within a callback function, the data will be sent to the same
network connection that generated the callback. Calling self.send_data is
exactly equivalent.
</p>
<p>
You can also call <a href="Connection.html#M000046">send_data</a> to write
to a connection <em>other than the one whose callback you are calling <a
href="Connection.html#M000046">send_data</a> from.</em> This is done by
recording the value of the connection in any callback function (the value
self), in any variable visible to other callback invocations on the same or
different connection objects. (Need an example to make that clear.)
</p>
					

					
					<div class="method-source-code"
						id="send-data-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 218</span>
218:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">send_data</span> <span class="ruby-identifier">data</span>
219:       <span class="ruby-identifier">data</span> = <span class="ruby-identifier">data</span>.<span class="ruby-identifier">to_s</span>
220:       <span class="ruby-identifier">size</span> = <span class="ruby-identifier">data</span>.<span class="ruby-identifier">bytesize</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:bytesize</span>)
221:       <span class="ruby-identifier">size</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">size</span>
222:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">send_data</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">size</span>
223:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="send-datagram-method" class="method-detail ">
				<a name="M000051"></a>

				<div class="method-heading">
				
					<span class="method-name">send_datagram</span><span
						class="method-args">(data, recipient_address, recipient_port)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000051">send_datagram</a> is for sending UDP
messages. This method may be called from any <a
href="Connection.html">Connection</a> object that refers to an open
datagram socket (see <a
href="../EventMachine.html#M000248">EventMachine#open_datagram_socket</a>).
The method sends a UDP (datagram) packet containing the data you specify,
to a remote peer specified by the IP address and port that you give as
parameters to the method. Observe that you may send a zero-length packet
(empty string). However, you may not send an arbitrarily-large data packet
because your operating system will enforce a platform-specific limit on the
size of the outbound packet. (Your kernel will respond in a
platform-specific way if you send an overlarge packet: some will send a
truncated packet, some will complain, and some will silently drop your
request). On LANs, it&#8217;s usually OK to send datagrams up to about 4000
bytes in length, but to be really safe, send messages smaller than the
Ethernet-packet size (typically about 1400 bytes). Some very restrictive
WANs will either drop or truncate packets larger than about 500 bytes.
</p>
					

					
					<div class="method-source-code"
						id="send-datagram-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 401</span>
401:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">send_datagram</span> <span class="ruby-identifier">data</span>, <span class="ruby-identifier">recipient_address</span>, <span class="ruby-identifier">recipient_port</span>
402:       <span class="ruby-identifier">data</span> = <span class="ruby-identifier">data</span>.<span class="ruby-identifier">to_s</span>
403:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">send_datagram</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span>, <span class="ruby-identifier">recipient_address</span>, <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">recipient_port</span>)
404:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="send-file-data-method" class="method-detail ">
				<a name="M000063"></a>

				<div class="method-heading">
				
					<span class="method-name">send_file_data</span><span
						class="method-args">(filename)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Like <a
href="Connection.html#M000046">EventMachine::Connection#send_data</a>, this
sends data to the remote end of the network connection. 
EventMachine::Connection@<a
href="Connection.html#M000063">send_file_data</a> takes a filename as an
argument, though, and sends the contents of the file, in one chunk.
Contributed by Kirk Haines.
</p>
					

					
					<div class="method-source-code"
						id="send-file-data-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 503</span>
503:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">send_file_data</span> <span class="ruby-identifier">filename</span>
504:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">send_file_data</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">filename</span>
505:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="set-comm-inactivity-timeout-method" class="method-detail ">
				<a name="M000058"></a>

				<div class="method-heading">
				
					<span class="method-name">set_comm_inactivity_timeout</span><span
						class="method-args">(value)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000056">comm_inactivity_timeout</a>= allows you
to set the inactivity-timeout property for a network connection or datagram
socket. Specify a non-negative float value in seconds. If the value is
greater than zero, the connection or socket will automatically be closed if
no read or write activity takes place for at least that number of seconds.
Specify a value of zero to indicate that no automatic timeout should take
place. Zero is the default value.
</p>
					

					
					<div class="method-source-code"
						id="set-comm-inactivity-timeout-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 469</span>
469:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">set_comm_inactivity_timeout</span> <span class="ruby-identifier">value</span>
470:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">set_comm_inactivity_timeout</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">value</span>.<span class="ruby-identifier">to_f</span>
471:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="set-pending-connect-timeout-method" class="method-detail ">
				<a name="M000061"></a>

				<div class="method-heading">
				
					<span class="method-name">set_pending_connect_timeout</span><span
						class="method-args">(value)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000061">set_pending_connect_timeout</a> sets the
duration after which a TCP connection in a connecting state will fail.
Takes a float in seconds.
</p>
					

					
					<div class="method-source-code"
						id="set-pending-connect-timeout-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 488</span>
488:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">set_pending_connect_timeout</span> <span class="ruby-identifier">value</span>
489:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">set_pending_connect_timeout</span> <span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">value</span>.<span class="ruby-identifier">to_f</span>
490:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="ssl-handshake-completed-method" class="method-detail ">
				<a name="M000036"></a>

				<div class="method-heading">
				
					<span class="method-name">ssl_handshake_completed</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000036">ssl_handshake_completed</a> is called by
<a href="../EventMachine.html">EventMachine</a> when the SSL/TLS handshake
has been completed, as a result of calling <a
href="Connection.html#M000049">start_tls</a> to initiate SSL/TLS on the
connection.
</p>
<p>
This callback exists because <a
href="Connection.html#M000034">post_init</a> and <a
href="Connection.html#M000048">connection_completed</a> are <b>not</b>
reliable for indicating when an SSL/TLS connection is ready to have
it&#8217;s certificate queried for.
</p>
<p>
See <a href="Connection.html#M000050">get_peer_cert</a> for application and
example.
</p>
					

					
					<div class="method-source-code"
						id="ssl-handshake-completed-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 107</span>
107:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">ssl_handshake_completed</span>
108:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="ssl-verify-peer-method" class="method-detail ">
				<a name="M000037"></a>

				<div class="method-heading">
				
					<span class="method-name">ssl_verify_peer</span><span
						class="method-args">(cert)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000037">ssl_verify_peer</a> is called by <a
href="../EventMachine.html">EventMachine</a> when :verify_peer => true has
been passed to <a href="Connection.html#M000049">start_tls</a>. It will be
called with each certificate in the certificate chain provided by the
remote peer. The cert will be passed as a String in PEM format, the same as
in <a href="Connection.html#M000050">get_peer_cert</a>. It is up to user
defined code to perform a check on the certificates. The return value from
this callback is used to accept or deny the peer. A return value that is
not nil or false triggers acceptance. If the peer is not accepted, the
connection will be subsequently closed. See
&#8216;tests/test_ssl_verify.rb&#8217; for a simple example.
</p>
					

					
					<div class="method-source-code"
						id="ssl-verify-peer-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 116</span>
116:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">ssl_verify_peer</span>(<span class="ruby-identifier">cert</span>)
117:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="start-tls-method" class="method-detail ">
				<a name="M000049"></a>

				<div class="method-heading">
				
					<span class="method-name">start_tls</span><span
						class="method-args">(args={})</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Call <a href="Connection.html#M000049">start_tls</a> at any point to
initiate TLS encryption on connected streams. The method is smart enough to
know whether it should perform a server-side or a client-side handshake. An
appropriate place to call <a href="Connection.html#M000049">start_tls</a>
is in your redefined <a href="Connection.html#M000034">post_init</a>
method, or in the <a
href="Connection.html#M000048">connection_completed</a> handler for an
outbound connection.
</p>
<p>
<a href="Connection.html#M000049">start_tls</a> takes an optional parameter
hash that allows you to specify certificate and other options to be used
with this <a href="Connection.html">Connection</a> object. Here are the
currently-supported options:
</p>
<ul>
<li><p>
:cert_chain_file :
</p>
</li>
</ul>
<p>
takes a String, which is interpreted as the name of a readable file in the
local filesystem. The file is expected to contain a chain of X509
certificates in PEM format, with the most-resolved certificate at the top
of the file, successive intermediate certs in the middle, and the root (or
CA) cert at the bottom.
</p>
<ul>
<li><p>
:private_key_file :
</p>
</li>
</ul>
<p>
takes a String, which is interpreted as the name of a readable file in the
local filesystem. The file must contain a private key in PEM format.
</p>
<ul>
<li><p>
:verify_peer :
</p>
</li>
</ul>
<p>
takes either true or false. Default is false. This indicates whether a
server should request a certificate from a peer, to be verified by user
code. If true, the <a href="Connection.html#M000037">ssl_verify_peer</a>
callback on the <a href="Connection.html">Connection</a> object is called
with each certificate in the certificate chain provided by the peer. See
documentation on <a href="Connection.html#M000037">ssl_verify_peer</a> for
how to use this.
</p>
<h3>Usage example:</h3>
<pre>
 require 'rubygems'
 require 'eventmachine'

 module Handler
   def post_init
     start_tls(:private_key_file =&gt; '/tmp/server.key', :cert_chain_file =&gt; '/tmp/server.crt', :verify_peer =&gt; false)
   end
 end

 EM.run {
   EM.start_server(&quot;127.0.0.1&quot;, 9999, Handler)
 }</pre>
					

					
					<div class="method-source-code"
						id="start-tls-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 299</span>
299:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">start_tls</span> <span class="ruby-identifier">args</span>={}
300:       <span class="ruby-identifier">priv_key</span>, <span class="ruby-identifier">cert_chain</span>, <span class="ruby-identifier">verify_peer</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:private_key_file</span>, <span class="ruby-value">:cert_chain_file</span>, <span class="ruby-value">:verify_peer</span>)
301: 
302:       [<span class="ruby-identifier">priv_key</span>, <span class="ruby-identifier">cert_chain</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">file</span><span class="ruby-operator">|</span>
303:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">file</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">file</span>.<span class="ruby-identifier">empty?</span>
304:         <span class="ruby-identifier">raise</span> <span class="ruby-constant">FileNotFoundException</span>,
305:           <span class="ruby-node">&quot;Could not find #{file} for start_tls&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span> <span class="ruby-identifier">file</span>
306:       <span class="ruby-keyword kw">end</span>
307: 
308:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">set_tls_parms</span>(<span class="ruby-ivar">@signature</span>, <span class="ruby-identifier">priv_key</span> <span class="ruby-operator">||</span> <span class="ruby-value str">''</span>, <span class="ruby-identifier">cert_chain</span> <span class="ruby-operator">||</span> <span class="ruby-value str">''</span>, <span class="ruby-identifier">verify_peer</span>)
309:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">start_tls</span> <span class="ruby-ivar">@signature</span>
310:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="stop-proxying-method" class="method-detail ">
				<a name="M000041"></a>

				<div class="method-heading">
				
					<span class="method-name">stop_proxying</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Helper method for EventMachine::disable_proxy(self)
</p>
					

					
					<div class="method-source-code"
						id="stop-proxying-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 146</span>
146:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">stop_proxying</span>
147:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">disable_proxy</span>(<span class="ruby-keyword kw">self</span>)
148:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="stream-file-data-method" class="method-detail ">
				<a name="M000064"></a>

				<div class="method-heading">
				
					<span class="method-name">stream_file_data</span><span
						class="method-args">(filename, args={})</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Open a file on the filesystem and send it to the remote peer. This returns
an object of type <a href="Deferrable.html">EventMachine::Deferrable</a>.
The object&#8217;s callbacks will be executed on the reactor main thread
when the file has been completely scheduled for transmission to the remote
peer. Its errbacks will be called in case of an error (such as
file-not-found). <a href="Connection.html#M000064">stream_file_data</a>
employs various strategems to achieve the fastest possible performance,
balanced against minimum consumption of memory.
</p>
<p>
You can control the behavior of <a
href="Connection.html#M000064">stream_file_data</a> with the optional
arguments parameter. Currently-supported arguments are: :http_chunks, a
boolean flag which defaults false. If true, this flag streams the file data
in a format compatible with the HTTP chunked-transfer encoding.
</p>
<p>
Warning: this feature has an implicit dependency on an outboard extension,
evma_fastfilereader. You must install this extension in order to use <a
href="Connection.html#M000064">stream_file_data</a> with files larger than
a certain size (currently 8192 bytes).
</p>
					

					
					<div class="method-source-code"
						id="stream-file-data-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 523</span>
523:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">stream_file_data</span> <span class="ruby-identifier">filename</span>, <span class="ruby-identifier">args</span>={}
524:       <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-constant">FileStreamer</span>.<span class="ruby-identifier">new</span>( <span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">filename</span>, <span class="ruby-identifier">args</span> )
525:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="unbind-method" class="method-detail ">
				<a name="M000038"></a>

				<div class="method-heading">
				
					<span class="method-name">unbind</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Connection.html#M000038">EventMachine::Connection#unbind</a> is
called by the framework whenever a connection (either a server or client
connection) is closed. The close can occur because your code intentionally
closes it (see <a href="Connection.html#M000042">close_connection</a> and
<a href="Connection.html#M000045">close_connection_after_writing</a>),
because the remote peer closed the connection, or because of a network
error. You may not assume that the network connection is still open and
able to send or receive data when the callback to unbind is made. This is
intended only to give you a chance to clean up associations your code may
have made to the connection object while it was open.
</p>
					

					
					<div class="method-source-code"
						id="unbind-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/connection.rb, line 128</span>
128:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">unbind</span>
129:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	

	</div>


	<div id="rdoc-debugging-section-dump" class="debugging-section">
	
		<p>Disabled; run with --debug to generate this.</p>
	
	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>

</body>
</html>

