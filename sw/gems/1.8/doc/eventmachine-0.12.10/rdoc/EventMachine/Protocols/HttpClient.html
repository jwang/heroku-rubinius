<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>Class: EventMachine::Protocols::HttpClient</title>

	<link rel="stylesheet" href="../../rdoc.css" type="text/css" media="screen" />

	<script src="../../js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../../js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../../js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../../js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>

</head>
<body class="class">

	<div id="metadata">
		<div id="home-metadata">
			<div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../../index.html">Home</a>
          <a href="../../index.html#classes">Classes</a>
          <a href="../../index.html#methods">Methods</a>
        </h3>
			</div>
		</div>

		<div id="file-metadata">
			<div id="file-list-section" class="section">
				<h3 class="section-header">In Files</h3>
				<div class="section-body">
					<ul>
					
						<li><a href="../../lib/em/protocols/httpclient_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/em/protocols/httpclient.rb">lib/em/protocols/httpclient.rb</a></li>
					
					</ul>
				</div>
			</div>

			
		</div>

		<div id="class-metadata">

			<!-- Parent Class -->
			
			<div id="parent-class-section" class="section">
				<h3 class="section-header">Parent</h3>
				
				<p class="link"><a href="../Connection.html">EventMachine::Connection</a></p>
				
			</div>
			

			<!-- Namespace Contents -->
			

			<!-- Method Quickref -->
			
			<div id="method-list-section" class="section">
				<h3 class="section-header">Methods</h3>
				<ul class="link-list">
					
					<li><a href="#M000105">::request</a></li>
					
					<li><a href="#M000107">#connection_completed</a></li>
					
					<li><a href="#M000111">#dispatch_response</a></li>
					
					<li><a href="#M000110">#parse_response_line</a></li>
					
					<li><a href="#M000106">#post_init</a></li>
					
					<li><a href="#M000109">#receive_data</a></li>
					
					<li><a href="#M000108">#send_request</a></li>
					
					<li><a href="#M000112">#unbind</a></li>
					
				</ul>
			</div>
			

			<!-- Included Modules -->
			
			<div id="includes-section" class="section">
				<h3 class="section-header">Included Modules</h3>
				<ul class="link-list">
				
				
					<li><a class="include" href="../Deferrable.html">EventMachine::Deferrable</a></li>
				
				
				</ul>
			</div>
			
		</div>

		<div id="project-metadata">
			
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="../../images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="../../EventMachine.html">EventMachine</a></li>
				
					<li><a href="../../EventMachine.html">EventMachine</a></li>
				
					<li><a href="../../EventMachine/Channel.html">EventMachine::Channel</a></li>
				
					<li><a href="../../EventMachine/Connection.html">EventMachine::Connection</a></li>
				
					<li><a href="../../EventMachine/ConnectionNotBound.html">EventMachine::ConnectionNotBound</a></li>
				
					<li><a href="../../EventMachine/DatagramObject.html">EventMachine::DatagramObject</a></li>
				
					<li><a href="../../EventMachine/DefaultDeferrable.html">EventMachine::DefaultDeferrable</a></li>
				
					<li><a href="../../EventMachine/Deferrable.html">EventMachine::Deferrable</a></li>
				
					<li><a href="../../EventMachine/DeferrableChildProcess.html">EventMachine::DeferrableChildProcess</a></li>
				
					<li><a href="../../EventMachine/Error.html">EventMachine::Error</a></li>
				
					<li><a href="../../EventMachine/EvmaKeyboard.html">EventMachine::EvmaKeyboard</a></li>
				
					<li><a href="../../EventMachine/EvmaTCPClient.html">EventMachine::EvmaTCPClient</a></li>
				
					<li><a href="../../EventMachine/EvmaTCPServer.html">EventMachine::EvmaTCPServer</a></li>
				
					<li><a href="../../EventMachine/EvmaUDPSocket.html">EventMachine::EvmaUDPSocket</a></li>
				
					<li><a href="../../EventMachine/EvmaUNIXClient.html">EventMachine::EvmaUNIXClient</a></li>
				
					<li><a href="../../EventMachine/EvmaUNIXServer.html">EventMachine::EvmaUNIXServer</a></li>
				
					<li><a href="../../EventMachine/FileStreamer.html">EventMachine::FileStreamer</a></li>
				
					<li><a href="../../EventMachine/FileWatch.html">EventMachine::FileWatch</a></li>
				
					<li><a href="../../EventMachine/JEM.html">EventMachine::JEM</a></li>
				
					<li><a href="../../EventMachine/LoopbreakReader.html">EventMachine::LoopbreakReader</a></li>
				
					<li><a href="../../EventMachine/PeriodicTimer.html">EventMachine::PeriodicTimer</a></li>
				
					<li><a href="../../EventMachine/ProcessWatch.html">EventMachine::ProcessWatch</a></li>
				
					<li><a href="../../EventMachine/Protocols.html">EventMachine::Protocols</a></li>
				
					<li><a href="../../EventMachine/Protocols.html">EventMachine::Protocols</a></li>
				
					<li><a href="../../EventMachine/Protocols/HeaderAndContentProtocol.html">EventMachine::Protocols::HeaderAndContentProtocol</a></li>
				
					<li><a href="../../EventMachine/Protocols/HttpClient.html">EventMachine::Protocols::HttpClient</a></li>
				
					<li><a href="../../EventMachine/Protocols/HttpClient2.html">EventMachine::Protocols::HttpClient2</a></li>
				
					<li><a href="../../EventMachine/Protocols/LineAndTextProtocol.html">EventMachine::Protocols::LineAndTextProtocol</a></li>
				
					<li><a href="../../EventMachine/Protocols/LineText2.html">EventMachine::Protocols::LineText2</a></li>
				
					<li><a href="../../EventMachine/Protocols/Memcache.html">EventMachine::Protocols::Memcache</a></li>
				
					<li><a href="../../EventMachine/Protocols/ObjectProtocol.html">EventMachine::Protocols::ObjectProtocol</a></li>
				
					<li><a href="../../EventMachine/Protocols/Postgres3.html">EventMachine::Protocols::Postgres3</a></li>
				
					<li><a href="../../EventMachine/Protocols/SASLauth.html">EventMachine::Protocols::SASLauth</a></li>
				
					<li><a href="../../EventMachine/Protocols/SASLauthclient.html">EventMachine::Protocols::SASLauthclient</a></li>
				
					<li><a href="../../EventMachine/Protocols/SmtpClient.html">EventMachine::Protocols::SmtpClient</a></li>
				
					<li><a href="../../EventMachine/Protocols/SmtpServer.html">EventMachine::Protocols::SmtpServer</a></li>
				
					<li><a href="../../EventMachine/Protocols/Socks4.html">EventMachine::Protocols::Socks4</a></li>
				
					<li><a href="../../EventMachine/Protocols/Stomp.html">EventMachine::Protocols::Stomp</a></li>
				
					<li><a href="../../EventMachine/Protocols/Stomp/Message.html">EventMachine::Protocols::Stomp::Message</a></li>
				
					<li><a href="../../EventMachine/Queue.html">EventMachine::Queue</a></li>
				
					<li><a href="../../EventMachine/Reactor.html">EventMachine::Reactor</a></li>
				
					<li><a href="../../EventMachine/Selectable.html">EventMachine::Selectable</a></li>
				
					<li><a href="../../EventMachine/SpawnedProcess.html">EventMachine::SpawnedProcess</a></li>
				
					<li><a href="../../EventMachine/StreamObject.html">EventMachine::StreamObject</a></li>
				
					<li><a href="../../EventMachine/Timer.html">EventMachine::Timer</a></li>
				
					<li><a href="../../EventMachine/UnknownTimerFired.html">EventMachine::UnknownTimerFired</a></li>
				
					<li><a href="../../EventMachine/Unsupported.html">EventMachine::Unsupported</a></li>
				
					<li><a href="../../EventMachine/UuidGenerator.html">EventMachine::UuidGenerator</a></li>
				
					<li><a href="../../Evma.html">Evma</a></li>
				
					<li><a href="../../Evma/Container.html">Evma::Container</a></li>
				
					<li><a href="../../Evma/ContainerHasObject.html">Evma::ContainerHasObject</a></li>
				
					<li><a href="../../Evma/DatagramProtocol.html">Evma::DatagramProtocol</a></li>
				
					<li><a href="../../Evma/Protocol.html">Evma::Protocol</a></li>
				
					<li><a href="../../Evma/ProtocolFactory.html">Evma::ProtocolFactory</a></li>
				
					<li><a href="../../Evma/Reactor.html">Evma::Reactor</a></li>
				
					<li><a href="../../Evma/StreamProtocol.html">Evma::StreamProtocol</a></li>
				
					<li><a href="../../Evma/TcpServerFactory.html">Evma::TcpServerFactory</a></li>
				
					<li><a href="../../Evma/TcpSocket.html">Evma::TcpSocket</a></li>
				
					<li><a href="../../Evma/UnknownTarget.html">Evma::UnknownTarget</a></li>
				
					<li><a href="../../Evma/UnsupportedCallback.html">Evma::UnsupportedCallback</a></li>
				
					<li><a href="../../BufferedTokenizer.html">BufferedTokenizer</a></li>
				
					<li><a href="../../IO.html">IO</a></li>
				
					<li><a href="../../JavaFields.html">JavaFields</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h1 class="class">EventMachine::Protocols::HttpClient</h1>

		<div id="description">
			<h3>Usage</h3>
<pre>
 EventMachine.run {
   http = EventMachine::Protocols::HttpClient.request(
     :host =&gt; server,
     :port =&gt; 80,
     :request =&gt; &quot;/index.html&quot;,
     :query_string =&gt; &quot;parm1=value1&amp;parm2=value2&quot;
   )
   http.callback {|response|
     puts response[:status]
     puts response[:headers]
     puts response[:content]
   }
 }</pre>

		</div>

		<!-- Constants -->
		
		<div id="constants-list" class="section">
			<h3 class="section-header">Constants</h3>
			<dl>
			
				<dt><a name="MaxPostContentLength">MaxPostContentLength</a></dt>
				
				<dd class="description"></dd>
				
			
			</dl>
		</div>
		

		<!-- Attributes -->
		

		<!-- Methods -->
		
		<div id="private-instance-method-details" class="method-section section">
			<h3 class="section-header">Private Instance Methods</h3>

		
			<div id="parse-response-line-method" class="method-detail ">
				<a name="M000110"></a>

				<div class="method-heading">
				
					<span class="method-name">parse_response_line</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
We get called here when we have received an HTTP response line. It&#8217;s
an opportunity to throw an exception or trigger other exceptional handling.
</p>
					

					
					<div class="method-source-code"
						id="parse-response-line-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 230</span>
230:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">parse_response_line</span>
231:         <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@headers</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/\AHTTP\/1\.[01] ([\d]{3})/</span>
232:           <span class="ruby-ivar">@status</span> = <span class="ruby-node">$1</span>.<span class="ruby-identifier">to_i</span>
233:         <span class="ruby-keyword kw">else</span>
234:           <span class="ruby-identifier">set_deferred_status</span> <span class="ruby-value">:failed</span>, {
235:             <span class="ruby-value">:status</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-comment cmt"># crappy way of signifying an unrecognized response. TODO, find a better way to do this.</span>
236:           }
237:           <span class="ruby-identifier">close_connection</span>
238:         <span class="ruby-keyword kw">end</span>
239:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	
		<div id="public-instance-method-details" class="method-section section">
			<h3 class="section-header">Public Instance Methods</h3>

		
			<div id="connection-completed-method" class="method-detail ">
				<a name="M000107"></a>

				<div class="method-heading">
				
					<span class="method-name">connection_completed</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
We send the request when we get a connection. AND, we set an instance
variable to indicate we passed through here. That allows <a
href="HttpClient.html#M000112">unbind</a> to know whether there was a
successful connection. NB: This naive technique won&#8217;t work when we
have to support multiple requests on a single connection.
</p>
					

					
					<div class="method-source-code"
						id="connection-completed-source">
<pre>
    <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 89</span>
89:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">connection_completed</span>
90:         <span class="ruby-ivar">@connected</span> = <span class="ruby-keyword kw">true</span>
91:         <span class="ruby-identifier">send_request</span> <span class="ruby-ivar">@args</span>
92:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="dispatch-response-method" class="method-detail ">
				<a name="M000111"></a>

				<div class="method-heading">
				
					<span class="method-name">dispatch_response</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="dispatch-response-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 242</span>
242:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">dispatch_response</span>
243:         <span class="ruby-ivar">@read_state</span> = <span class="ruby-value">:base</span>
244:         <span class="ruby-identifier">set_deferred_status</span> <span class="ruby-value">:succeeded</span>, {
245:           <span class="ruby-value">:content</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@content</span>,
246:           <span class="ruby-value">:headers</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@headers</span>,
247:           <span class="ruby-value">:status</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@status</span>
248:         }
249:         <span class="ruby-comment cmt"># TODO, we close the connection for now, but this is wrong for persistent clients.</span>
250:         <span class="ruby-identifier">close_connection</span>
251:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="post-init-method" class="method-detail ">
				<a name="M000106"></a>

				<div class="method-heading">
				
					<span class="method-name">post_init</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="post-init-source">
<pre>
    <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 78</span>
78:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">post_init</span>
79:         <span class="ruby-ivar">@start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
80:         <span class="ruby-ivar">@data</span> = <span class="ruby-value str">&quot;&quot;</span>
81:         <span class="ruby-ivar">@read_state</span> = <span class="ruby-value">:base</span>
82:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="receive-data-method" class="method-detail ">
				<a name="M000109"></a>

				<div class="method-heading">
				
					<span class="method-name">receive_data</span><span
						class="method-args">(data)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="receive-data-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 161</span>
161:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">receive_data</span> <span class="ruby-identifier">data</span>
162:         <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">data</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
163:           <span class="ruby-keyword kw">case</span> <span class="ruby-ivar">@read_state</span>
164:           <span class="ruby-keyword kw">when</span> <span class="ruby-value">:base</span>
165:             <span class="ruby-comment cmt"># Perform any per-request initialization here and don't consume any data.</span>
166:             <span class="ruby-ivar">@data</span> = <span class="ruby-value str">&quot;&quot;</span>
167:             <span class="ruby-ivar">@headers</span> = []
168:             <span class="ruby-ivar">@content_length</span> = <span class="ruby-keyword kw">nil</span> <span class="ruby-comment cmt"># not zero</span>
169:             <span class="ruby-ivar">@content</span> = <span class="ruby-value str">&quot;&quot;</span>
170:             <span class="ruby-ivar">@status</span> = <span class="ruby-keyword kw">nil</span>
171:             <span class="ruby-ivar">@read_state</span> = <span class="ruby-value">:header</span>
172:             <span class="ruby-ivar">@connection_close</span> = <span class="ruby-keyword kw">nil</span>
173:           <span class="ruby-keyword kw">when</span> <span class="ruby-value">:header</span>
174:             <span class="ruby-identifier">ary</span> = <span class="ruby-identifier">data</span>.<span class="ruby-identifier">split</span>( <span class="ruby-regexp re">/\r?\n/</span>, <span class="ruby-value">2</span> )
175:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>
176:               <span class="ruby-identifier">data</span> = <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">last</span>
177:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;&quot;</span>
178:                 <span class="ruby-keyword kw">if</span> (<span class="ruby-ivar">@content_length</span> <span class="ruby-keyword kw">and</span> <span class="ruby-ivar">@content_length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>) <span class="ruby-operator">||</span> <span class="ruby-ivar">@connection_close</span>
179:                   <span class="ruby-ivar">@read_state</span> = <span class="ruby-value">:content</span>
180:                 <span class="ruby-keyword kw">else</span>
181:                   <span class="ruby-identifier">dispatch_response</span>
182:                   <span class="ruby-ivar">@read_state</span> = <span class="ruby-value">:base</span>
183:                 <span class="ruby-keyword kw">end</span>
184:               <span class="ruby-keyword kw">else</span>
185:                 <span class="ruby-ivar">@headers</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">first</span>
186:                 <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@headers</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
187:                   <span class="ruby-identifier">parse_response_line</span>
188:                 <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/\Acontent-length:\s*/</span>
189:                   <span class="ruby-comment cmt"># Only take the FIRST content-length header that appears,</span>
190:                   <span class="ruby-comment cmt"># which we can distinguish because @content_length is nil.</span>
191:                   <span class="ruby-comment cmt"># TODO, it's actually a fatal error if there is more than one</span>
192:                   <span class="ruby-comment cmt"># content-length header, because the caller is presumptively</span>
193:                   <span class="ruby-comment cmt"># a bad guy. (There is an exploit that depends on multiple</span>
194:                   <span class="ruby-comment cmt"># content-length headers.)</span>
195:                   <span class="ruby-ivar">@content_length</span> <span class="ruby-operator">||=</span> <span class="ruby-node">$'</span>.<span class="ruby-identifier">to_i</span>
196:                 <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/\Aconnection:\s*close/</span>
197:                   <span class="ruby-ivar">@connection_close</span> = <span class="ruby-keyword kw">true</span>
198:                 <span class="ruby-keyword kw">end</span>
199:               <span class="ruby-keyword kw">end</span>
200:             <span class="ruby-keyword kw">else</span>
201:               <span class="ruby-ivar">@data</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">data</span>
202:               <span class="ruby-identifier">data</span> = <span class="ruby-value str">&quot;&quot;</span>
203:             <span class="ruby-keyword kw">end</span>
204:           <span class="ruby-keyword kw">when</span> <span class="ruby-value">:content</span>
205:             <span class="ruby-comment cmt"># If there was no content-length header, we have to wait until the connection</span>
206:             <span class="ruby-comment cmt"># closes. Everything we get until that point is content.</span>
207:             <span class="ruby-comment cmt"># TODO: Must impose a content-size limit, and also must implement chunking.</span>
208:             <span class="ruby-comment cmt"># Also, must support either temporary files for large content, or calling</span>
209:             <span class="ruby-comment cmt"># a content-consumer block supplied by the user.</span>
210:             <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@content_length</span>
211:               <span class="ruby-identifier">bytes_needed</span> = <span class="ruby-ivar">@content_length</span> <span class="ruby-operator">-</span> <span class="ruby-ivar">@content</span>.<span class="ruby-identifier">length</span>
212:               <span class="ruby-ivar">@content</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">data</span>[<span class="ruby-value">0</span>, <span class="ruby-identifier">bytes_needed</span>]
213:               <span class="ruby-identifier">data</span> = <span class="ruby-identifier">data</span>[<span class="ruby-identifier">bytes_needed</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">&quot;&quot;</span>
214:               <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@content_length</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@content</span>.<span class="ruby-identifier">length</span>
215:                 <span class="ruby-identifier">dispatch_response</span>
216:                 <span class="ruby-ivar">@read_state</span> = <span class="ruby-value">:base</span>
217:               <span class="ruby-keyword kw">end</span>
218:             <span class="ruby-keyword kw">else</span>
219:               <span class="ruby-ivar">@content</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">data</span>
220:               <span class="ruby-identifier">data</span> = <span class="ruby-value str">&quot;&quot;</span>
221:             <span class="ruby-keyword kw">end</span>
222:           <span class="ruby-keyword kw">end</span>
223:         <span class="ruby-keyword kw">end</span>
224:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="send-request-method" class="method-detail ">
				<a name="M000108"></a>

				<div class="method-heading">
				
					<span class="method-name">send_request</span><span
						class="method-args">(args)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="send-request-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 94</span>
 94:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">send_request</span> <span class="ruby-identifier">args</span>
 95:         <span class="ruby-identifier">args</span>[<span class="ruby-value">:verb</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">:method</span>] <span class="ruby-comment cmt"># Support :method as an alternative to :verb.</span>
 96:         <span class="ruby-identifier">args</span>[<span class="ruby-value">:verb</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">:get</span> <span class="ruby-comment cmt"># IS THIS A GOOD IDEA, to default to GET if nothing was specified?</span>
 97: 
 98:         <span class="ruby-identifier">verb</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:verb</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">upcase</span>
 99:         <span class="ruby-keyword kw">unless</span> [<span class="ruby-value str">&quot;GET&quot;</span>, <span class="ruby-value str">&quot;POST&quot;</span>, <span class="ruby-value str">&quot;PUT&quot;</span>, <span class="ruby-value str">&quot;DELETE&quot;</span>, <span class="ruby-value str">&quot;HEAD&quot;</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">verb</span>)
100:           <span class="ruby-identifier">set_deferred_status</span> <span class="ruby-value">:failed</span>, {<span class="ruby-value">:status</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>} <span class="ruby-comment cmt"># TODO, not signalling the error type</span>
101:           <span class="ruby-keyword kw">return</span> <span class="ruby-comment cmt"># NOTE THE EARLY RETURN, we're not sending any data.</span>
102:         <span class="ruby-keyword kw">end</span>
103: 
104:         <span class="ruby-identifier">request</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:request</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">&quot;/&quot;</span>
105:         <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">request</span>[<span class="ruby-value">0</span>,<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;/&quot;</span>
106:           <span class="ruby-identifier">request</span> = <span class="ruby-value str">&quot;/&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">request</span>
107:         <span class="ruby-keyword kw">end</span>
108: 
109:         <span class="ruby-identifier">qs</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:query_string</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">&quot;&quot;</span>
110:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">qs</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">qs</span>[<span class="ruby-value">0</span>,<span class="ruby-value">1</span>] <span class="ruby-operator">!=</span> <span class="ruby-value str">'?'</span>
111:           <span class="ruby-identifier">qs</span> = <span class="ruby-value str">&quot;?&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">qs</span>
112:         <span class="ruby-keyword kw">end</span>
113: 
114:         <span class="ruby-identifier">version</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:version</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">&quot;1.1&quot;</span>
115: 
116:         <span class="ruby-comment cmt"># Allow an override for the host header if it's not the connect-string.</span>
117:         <span class="ruby-identifier">host</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:host_header</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">:host</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">&quot;_&quot;</span>
118:         <span class="ruby-comment cmt"># For now, ALWAYS tuck in the port string, although we may want to omit it if it's the default.</span>
119:         <span class="ruby-identifier">port</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:port</span>]
120: 
121:         <span class="ruby-comment cmt"># POST items.</span>
122:         <span class="ruby-identifier">postcontenttype</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:contenttype</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">&quot;application/octet-stream&quot;</span>
123:         <span class="ruby-identifier">postcontent</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">:content</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">&quot;&quot;</span>
124:         <span class="ruby-identifier">raise</span> <span class="ruby-value str">&quot;oversized content in HTTP POST&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">postcontent</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-constant">MaxPostContentLength</span>
125: 
126:         <span class="ruby-comment cmt"># ESSENTIAL for the request's line-endings to be CRLF, not LF. Some servers misbehave otherwise.</span>
127:         <span class="ruby-comment cmt"># TODO: We ASSUME the caller wants to send a 1.1 request. May not be a good assumption.</span>
128:         <span class="ruby-identifier">req</span> = [
129:           <span class="ruby-node">&quot;#{verb} #{request}#{qs} HTTP/#{version}&quot;</span>,
130:           <span class="ruby-node">&quot;Host: #{host}:#{port}&quot;</span>,
131:           <span class="ruby-value str">&quot;User-agent: Ruby EventMachine&quot;</span>,
132:         ]
133: 
134:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">verb</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;POST&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">verb</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;PUT&quot;</span>
135:             <span class="ruby-identifier">req</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;Content-type: #{postcontenttype}&quot;</span>
136:             <span class="ruby-identifier">req</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;Content-length: #{postcontent.length}&quot;</span>
137:           <span class="ruby-keyword kw">end</span>
138: 
139:           <span class="ruby-comment cmt"># TODO, this cookie handler assumes it's getting a single, semicolon-delimited string.</span>
140:           <span class="ruby-comment cmt"># Eventually we will want to deal intelligently with arrays and hashes.</span>
141:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">:cookie</span>]
142:             <span class="ruby-identifier">req</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;Cookie: #{args[:cookie]}&quot;</span>
143:           <span class="ruby-keyword kw">end</span>
144: 
145:           <span class="ruby-comment cmt"># Basic-auth stanza contributed by Matt Murphy.</span>
146:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">:basic_auth</span>]
147:             <span class="ruby-identifier">basic_auth_string</span> = [<span class="ruby-node">&quot;#{args[:basic_auth][:username]}:#{args[:basic_auth][:password]}&quot;</span>].<span class="ruby-identifier">pack</span>(<span class="ruby-value str">'m'</span>).<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp re">/\n/</span>,<span class="ruby-value str">''</span>)
148:             <span class="ruby-identifier">req</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;Authorization: Basic #{basic_auth_string}&quot;</span>
149:           <span class="ruby-keyword kw">end</span>
150: 
151:           <span class="ruby-identifier">req</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot;&quot;</span>
152:           <span class="ruby-identifier">reqstring</span> = <span class="ruby-identifier">req</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;#{l}\r\n&quot;</span>}.<span class="ruby-identifier">join</span>
153:           <span class="ruby-identifier">send_data</span> <span class="ruby-identifier">reqstring</span>
154: 
155:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">verb</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;POST&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">verb</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;PUT&quot;</span>
156:             <span class="ruby-identifier">send_data</span> <span class="ruby-identifier">postcontent</span>
157:           <span class="ruby-keyword kw">end</span>
158:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="unbind-method" class="method-detail ">
				<a name="M000112"></a>

				<div class="method-heading">
				
					<span class="method-name">unbind</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					
					

					
					<div class="method-source-code"
						id="unbind-source">
<pre>
     <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 253</span>
253:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">unbind</span>
254:         <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@connected</span>
255:           <span class="ruby-identifier">set_deferred_status</span> <span class="ruby-value">:failed</span>, {<span class="ruby-value">:status</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>} <span class="ruby-comment cmt"># YECCCCH. Find a better way to signal no-connect/network error.</span>
256:         <span class="ruby-keyword kw">elsif</span> (<span class="ruby-ivar">@read_state</span> <span class="ruby-operator">==</span> <span class="ruby-value">:content</span> <span class="ruby-keyword kw">and</span> <span class="ruby-ivar">@content_length</span> <span class="ruby-operator">==</span> <span class="ruby-keyword kw">nil</span>)
257:           <span class="ruby-identifier">dispatch_response</span>
258:         <span class="ruby-keyword kw">end</span>
259:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	
		<div id="public-class-method-details" class="method-section section">
			<h3 class="section-header">Public Class Methods</h3>

		
			<div id="request-method" class="method-detail ">
				<a name="M000105"></a>

				<div class="method-heading">
				
					<span class="method-name">request</span><span
						class="method-args">( args = {} )</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<h3>Arg list</h3>
<p>
:host => &#8216;ip/dns&#8217;, :port => fixnum, :verb => &#8216;GET&#8217;,
:request => &#8216;path&#8217;, :basic_auth => {:username =>
&#8217;&#8217;, :password => &#8217;&#8217;}, :content =>
&#8216;content&#8217;, :contenttype => &#8216;text/plain&#8217;,
:query_string => &#8217;&#8217;, :host_header => &#8217;&#8217;, :cookie =>
&#8217;&#8217;
</p>
					

					
					<div class="method-source-code"
						id="request-source">
<pre>
    <span class="ruby-comment cmt"># File lib/em/protocols/httpclient.rb, line 70</span>
70:       <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">request</span>( <span class="ruby-identifier">args</span> = {} )
71:         <span class="ruby-identifier">args</span>[<span class="ruby-value">:port</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">80</span>
72:         <span class="ruby-constant">EventMachine</span>.<span class="ruby-identifier">connect</span>( <span class="ruby-identifier">args</span>[<span class="ruby-value">:host</span>], <span class="ruby-identifier">args</span>[<span class="ruby-value">:port</span>], <span class="ruby-keyword kw">self</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
73:           <span class="ruby-comment cmt"># According to the docs, we will get here AFTER post_init is called.</span>
74:           <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_eval</span> {<span class="ruby-ivar">@args</span> = <span class="ruby-identifier">args</span>}
75:         }
76:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	

	</div>


	<div id="rdoc-debugging-section-dump" class="debugging-section">
	
		<p>Disabled; run with --debug to generate this.</p>
	
	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>

</body>
</html>

